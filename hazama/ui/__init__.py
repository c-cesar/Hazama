from PySide.QtGui import QApplication, QIcon, QFont, QFontMetrics, QMessageBox
from PySide.QtCore import QLocale, QTranslator, QLibraryInfo, QDateTime, QFile
import sys
import os
import time
import logging
from hazama.config import settings, appPath
import hazama.ui.rc


locale = None
timeFmt = dateFmt = datetimeFmt = None
font = None


def datetimeTrans(s, forceDateOnly=False):
    """Convert datetime in database format to locale one"""
    dt = QDateTime.fromString(s, 'yyyy-MM-dd HH:mm')
    return locale.toString(dt, dateFmt if forceDateOnly else datetimeFmt)


def currentDatetime():
    """Return current datetime in database format"""
    return time.strftime('%Y-%m-%d %H:%M')


def readRcTextFile(path):
    """Read whole text file from qt resources system"""
    f = QFile(path)
    if not f.open(QFile.ReadOnly | QFile.Text):
        raise Exception('read rc text failed')
    text = str(f.readAll())
    f.close()
    return text


def setTranslationLocale():
    global locale
    lang = settings['Main'].get('lang')
    sysLocale = QLocale.system()
    if lang and lang == sysLocale.name():
        locale = sysLocale
    elif lang and lang != sysLocale.name():
        # special case: application language is different from system's
        locale = QLocale(lang)
        QLocale.setDefault(locale)
    else:
        locale = sysLocale
        lang = settings['Main']['lang'] = locale.name()
    langPath = os.path.join(appPath, 'lang')
    logging.info('set translation(%s)', lang)
    global _trans, _transQt  # avoid being collected
    _trans = QTranslator()
    _trans.load(lang, langPath)
    _transQt = QTranslator()
    ret = _transQt.load('qt_' + lang,
                        QLibraryInfo.location(QLibraryInfo.TranslationsPath))
    if not ret:  # frozen
        _transQt.load('qt_'+lang, langPath)
    for i in [_trans, _transQt]: QApplication.instance().installTranslator(i)

    global timeFmt, dateFmt, datetimeFmt
    timeFmt = settings['Main'].get('timeFormat')
    dateFmt = settings['Main'].get('dateFormat', locale.dateFormat())
    datetimeFmt = (dateFmt + ' ' + timeFmt) if timeFmt else dateFmt


def showErrors(type, **extra_args):
    """Show information about variety of errors."""
    app = QApplication.instance()
    if not app:
        app = init()
    {'dbError': lambda hint='': QMessageBox.critical(
        None,
        app.translate('Errors', 'Failed to access database'),
        app.translate('Errors', 'SQLite3: %s.\n\nPlease check database path(have permission?). '
                      'If it\'s corrupt, you may have to recover this file by hand or restore '
                      'from backups.') % hint),
     'dbLocked': lambda: QMessageBox.warning(
         None,
         app.translate('Errors', 'Multiple access error'),
         app.translate('Errors', 'This diary book is already open.')),
     'cantFile': lambda info: QMessageBox.warning(
         None,
         app.translate('Errors', 'Failed to access file'),
         app.translate('Errors', info))
     }[type](**extra_args)


def setStdEditMenuIcons(menu):
    """Add system theme icons to QLineEdit and QTextEdit context-menu
    :param menu: QMenu generated by createStandardContextMenu
    """
    (undo, redo, __, cut, copy, paste, delete, __, sel, *__) = menu.actions()
    undo.setIcon(QIcon.fromTheme('edit-undo'))
    redo.setIcon(QIcon.fromTheme('edit-redo'))
    cut.setIcon(QIcon.fromTheme('edit-cut'))
    copy.setIcon(QIcon.fromTheme('edit-copy'))
    paste.setIcon(QIcon.fromTheme('edit-paste'))
    delete.setIcon(QIcon.fromTheme('edit-delete'))
    sel.setIcon(QIcon.fromTheme('edit-select-all'))


def setStyleSheet():
    """If -stylesheet not in sys.argv, append custom.qss(if exists) to default one and
    load it. Otherwise load the one in sys.argv"""
    if '-stylesheet' in sys.argv:
        logging.info('override default StyleSheet by command line arg')
    else:
        ss = [readRcTextFile(':/default.qss')]
        # append theme part
        theme = settings['Main'].get('theme')
        if theme == 'colorful':
            ss.append(readRcTextFile(':/theme.colorful.qss'))
        # load custom
        if os.path.isfile('custom.qss'):
            logging.info('set custom StyleSheet')
            with open('custom.qss', encoding='utf-8') as f:
                ss.append(f.read())

        QApplication.instance().setStyleSheet(''.join(ss))


def winDwmExtendWindowFrame(winId, topMargin):
    """Extend background of title bar to toolbar. Only available on Windows
    because it depends on DWM. winId is PyCapsule object, which storing HWND."""
    if not isDwmUsable(): return
    from ctypes import (c_int, byref, pythonapi, c_void_p, c_char_p, py_object,
                        windll, Structure)

    # define prototypes & structures
    class Margin(Structure):
        _fields_ = [('left', c_int), ('right', c_int),
                    ('top', c_int), ('bottom', c_int)]
    pythonapi.PyCapsule_GetPointer.restype = c_void_p
    pythonapi.PyCapsule_GetPointer.argtypes = [py_object, c_char_p]

    winId = pythonapi.PyCapsule_GetPointer(winId, None)
    margin = Margin(0, 0, topMargin, 0)
    windll.dwmapi.DwmExtendFrameIntoClientArea(winId, byref(margin))

    return True


def isDwmUsable():
    """Check whether winDwmExtendWindowFrame usable."""
    if sys.platform != 'win32': return False
    from ctypes import byref, windll, c_bool
    # check if DWM enabled
    ver = sys.getwindowsversion()
    # potential bug: windows 8 or later always have DWM enabled,
    # but API used below depends on manifest file. so check version
    if ver.major <= 6 and ver.minor <= 1:  # Windows is 7 or older
        b = c_bool()
        try:
            ret = windll.dwmapi.DwmIsCompositionEnabled(byref(b))
        except AttributeError:  # no DWM, Windows is older than vista
            return False
        if not (ret == 0 and b.value): return False
    return True


def getDpiScaleRatio(forceMultipleOf25=True):
    dpi = QApplication.instance().desktop().logicalDpiX()  # when will x != y happen?
    ratio = dpi / 96
    if forceMultipleOf25 and round(ratio % .25, 2) != 0:
        ratio = round(ratio - ratio % .25, 2)
    return ratio


def fixWidgetSizeOnHiDpi(widget):
    """Simply resize those hardcoded sizes (at ratio 1.0), and ignore sizes changed by user.
    Because per-monitor DPI aware is not supported, user's size will be saved
    directly."""
    widget.resize(widget.size() * getDpiScaleRatio(False))


class Fonts:
    """Manage all fonts used in application"""
    def __init__(self):
        self.title = QFont()
        self.datetime = QFont()
        self.text = QFont()
        self.default = QApplication.instance().font()
        self.default_m = QFontMetrics(self.default, None)
        self.title_m = self.datetime_m = self.text_m = None

    def load(self):
        # passing None as 2nd arg to QFontMetrics make difference on high DPI
        self.title.fromString(settings['Font'].get('title'))
        self.title_m = QFontMetrics(self.title, None)
        self.datetime.fromString(settings['Font'].get('datetime'))
        self.datetime_m = QFontMetrics(self.datetime, None)
        self.text.fromString(settings['Font'].get('text'))
        self.text_m = QFontMetrics(self.text, None)
        if 'default' in settings['Font']:
            self.default.fromString(settings['Font'].get('default'))
            self.default_m = QFontMetrics(self.default, None)
            QApplication.instance().setFont(self.default)


def init():
    app = QApplication(sys.argv)
    logging.debug('DPI scale ratio %s' % getDpiScaleRatio())

    ico = QIcon()
    for i in [16, 64]:
        ico.addFile(':/appicon-%d.png' % i)
    app.setWindowIcon(ico)

    global font
    font = Fonts()
    font.load()

    setTranslationLocale()
    setStyleSheet()
    return app
